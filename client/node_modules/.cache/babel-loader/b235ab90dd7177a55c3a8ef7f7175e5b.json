{"ast":null,"code":"// api/stream.js\nimport historyProvider from './historyProvider.js'; // we use Socket.io client to connect to cryptocompare's socket.io stream\n\nvar io = require('socket.io-client');\n\nvar socket_url = 'wss://streamer.cryptocompare.com';\nvar socket = io(socket_url); // keep track of subscriptions\n\nvar _subs = [];\nexport default {\n  subscribeBars: function subscribeBars(symbolInfo, resolution, updateCb, uid, resetCache) {\n    var channelString = createChannelString(symbolInfo);\n    socket.emit('SubAdd', {\n      subs: [channelString]\n    });\n    var newSub = {\n      channelString: channelString,\n      uid: uid,\n      resolution: resolution,\n      symbolInfo: symbolInfo,\n      lastBar: historyProvider.history[symbolInfo.name].lastBar,\n      listener: updateCb\n    };\n\n    _subs.push(newSub);\n  },\n  unsubscribeBars: function unsubscribeBars(uid) {\n    var subIndex = _subs.findIndex(function (e) {\n      return e.uid === uid;\n    });\n\n    if (subIndex === -1) {\n      //console.log(\"No subscription found for \",uid)\n      return;\n    }\n\n    var sub = _subs[subIndex];\n    socket.emit('SubRemove', {\n      subs: [sub.channelString]\n    });\n\n    _subs.splice(subIndex, 1);\n  }\n};\nsocket.on('connect', function () {\n  console.log('===Socket connected');\n});\nsocket.on('disconnect', function (e) {\n  console.log('===Socket disconnected:', e);\n});\nsocket.on('error', function (err) {\n  console.log('====socket error', err);\n});\nsocket.on('m', function (e) {\n  // here we get all events the CryptoCompare connection has subscribed to\n  // we need to send this new data to our subscribed charts\n  var _data = e.split('~');\n\n  if (_data[0] === \"3\") {\n    // console.log('Websocket Snapshot load event complete')\n    return;\n  }\n\n  var data = {\n    sub_type: parseInt(_data[0], 10),\n    exchange: _data[1],\n    to_sym: _data[2],\n    from_sym: _data[3],\n    trade_id: _data[5],\n    ts: parseInt(_data[6], 10),\n    volume: parseFloat(_data[7]),\n    price: parseFloat(_data[8])\n  };\n  var channelString = \"\".concat(data.sub_type, \"~\").concat(data.exchange, \"~\").concat(data.to_sym, \"~\").concat(data.from_sym);\n\n  var sub = _subs.find(function (e) {\n    return e.channelString === channelString;\n  });\n\n  if (sub) {\n    // disregard the initial catchup snapshot of trades for already closed candles\n    if (data.ts < sub.lastBar.time / 1000) {\n      return;\n    }\n\n    var _lastBar = updateBar(data, sub); // send the most recent bar back to TV's realtimeUpdate callback\n\n\n    sub.listener(_lastBar); // update our own record of lastBar\n\n    sub.lastBar = _lastBar;\n  }\n}); // Take a single trade, and subscription record, return updated bar\n\nfunction updateBar(data, sub) {\n  var lastBar = sub.lastBar;\n  var resolution = sub.resolution;\n\n  if (resolution.includes('D')) {\n    // 1 day in minutes === 1440\n    resolution = 1440;\n  } else if (resolution.includes('W')) {\n    // 1 week in minutes === 10080\n    resolution = 10080;\n  }\n\n  var coeff = resolution * 60; // console.log({coeff})\n\n  var rounded = Math.floor(data.ts / coeff) * coeff;\n  var lastBarSec = lastBar.time / 1000;\n\n  var _lastBar;\n\n  if (rounded > lastBarSec) {\n    // create a new candle, use last close as open **PERSONAL CHOICE**\n    _lastBar = {\n      time: rounded * 1000,\n      open: lastBar.close,\n      high: lastBar.close,\n      low: lastBar.close,\n      close: data.price,\n      volume: data.volume\n    };\n  } else {\n    // update lastBar candle!\n    if (data.price < lastBar.low) {\n      lastBar.low = data.price;\n    } else if (data.price > lastBar.high) {\n      lastBar.high = data.price;\n    }\n\n    lastBar.volume += data.volume;\n    lastBar.close = data.price;\n    _lastBar = lastBar;\n  }\n\n  return _lastBar;\n} // takes symbolInfo object as input and creates the subscription string to send to CryptoCompare\n\n\nfunction createChannelString(symbolInfo) {\n  var channel = symbolInfo.name.split(/[:/]/);\n  var exchange = channel[0] === 'GDAX' ? 'Coinbase' : channel[0];\n  var to = channel[2];\n  var from = channel[1]; // subscribe to the CryptoCompare trade channel for the pair and exchange\n\n  return \"0~\".concat(exchange, \"~\").concat(from, \"~\").concat(to);\n}","map":{"version":3,"sources":["/Applications/XAMPP/xamppfiles/htdocs/dapp/byzanti/AdminPanel/client/src/components/TVChartContainer/api/stream.js"],"names":["historyProvider","io","require","socket_url","socket","_subs","subscribeBars","symbolInfo","resolution","updateCb","uid","resetCache","channelString","createChannelString","emit","subs","newSub","lastBar","history","name","listener","push","unsubscribeBars","subIndex","findIndex","e","sub","splice","on","console","log","err","_data","split","data","sub_type","parseInt","exchange","to_sym","from_sym","trade_id","ts","volume","parseFloat","price","find","time","_lastBar","updateBar","includes","coeff","rounded","Math","floor","lastBarSec","open","close","high","low","channel","to","from"],"mappings":"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","sourcesContent":["// api/stream.js\nimport historyProvider from './historyProvider.js'\n// we use Socket.io client to connect to cryptocompare's socket.io stream\nvar io = require('socket.io-client')\nvar socket_url = 'wss://streamer.cryptocompare.com'\nvar socket = io(socket_url)\n// keep track of subscriptions\nvar _subs = []\n\nexport default {\n subscribeBars: function(symbolInfo, resolution, updateCb, uid, resetCache) {\n  const channelString = createChannelString(symbolInfo)\n  socket.emit('SubAdd', {subs: [channelString]})\n  \n  var newSub = {\n   channelString,\n   uid,\n   resolution,\n   symbolInfo,\n   lastBar: historyProvider.history[symbolInfo.name].lastBar,\n   listener: updateCb,\n  }\n_subs.push(newSub)\n },\n unsubscribeBars: function(uid) {\n  var subIndex = _subs.findIndex(e => e.uid === uid)\n  if (subIndex === -1) {\n   //console.log(\"No subscription found for \",uid)\n   return\n  }\n  var sub = _subs[subIndex]\n  socket.emit('SubRemove', {subs: [sub.channelString]})\n  _subs.splice(subIndex, 1)\n }\n}\n\nsocket.on('connect', () => {\n console.log('===Socket connected')\n})\nsocket.on('disconnect', (e) => {\n console.log('===Socket disconnected:', e)\n})\nsocket.on('error', err => {\n console.log('====socket error', err)\n})\nsocket.on('m', (e) => {\n // here we get all events the CryptoCompare connection has subscribed to\n // we need to send this new data to our subscribed charts\n const _data= e.split('~')\n if (_data[0] === \"3\") {\n  // console.log('Websocket Snapshot load event complete')\n  return\n }\n const data = {\n  sub_type: parseInt(_data[0],10),\n  exchange: _data[1],\n  to_sym: _data[2],\n  from_sym: _data[3],\n  trade_id: _data[5],\n  ts: parseInt(_data[6],10),\n  volume: parseFloat(_data[7]),\n  price: parseFloat(_data[8])\n }\n \n const channelString = `${data.sub_type}~${data.exchange}~${data.to_sym}~${data.from_sym}`\n \n const sub = _subs.find(e => e.channelString === channelString)\n \n if (sub) {\n  // disregard the initial catchup snapshot of trades for already closed candles\n  if (data.ts < sub.lastBar.time / 1000) {\n    return\n   }\n  \nvar _lastBar = updateBar(data, sub)\n\n// send the most recent bar back to TV's realtimeUpdate callback\n  sub.listener(_lastBar)\n  // update our own record of lastBar\n  sub.lastBar = _lastBar\n }\n})\n\n// Take a single trade, and subscription record, return updated bar\nfunction updateBar(data, sub) {\n var lastBar = sub.lastBar\n let resolution = sub.resolution\n if (resolution.includes('D')) {\n  // 1 day in minutes === 1440\n  resolution = 1440\n } else if (resolution.includes('W')) {\n  // 1 week in minutes === 10080\n  resolution = 10080\n }\nvar coeff = resolution * 60\n // console.log({coeff})\n var rounded = Math.floor(data.ts / coeff) * coeff\n var lastBarSec = lastBar.time / 1000\n var _lastBar\n \nif (rounded > lastBarSec) {\n  // create a new candle, use last close as open **PERSONAL CHOICE**\n  _lastBar = {\n   time: rounded * 1000,\n   open: lastBar.close,\n   high: lastBar.close,\n   low: lastBar.close,\n   close: data.price,\n   volume: data.volume\n  }\n  \n } else {\n  // update lastBar candle!\n  if (data.price < lastBar.low) {\n   lastBar.low = data.price\n  } else if (data.price > lastBar.high) {\n   lastBar.high = data.price\n  }\n  \n  lastBar.volume += data.volume\n  lastBar.close = data.price\n  _lastBar = lastBar\n }\n return _lastBar\n}\n\n// takes symbolInfo object as input and creates the subscription string to send to CryptoCompare\nfunction createChannelString(symbolInfo) {\n  var channel = symbolInfo.name.split(/[:/]/)\n  const exchange = channel[0] === 'GDAX' ? 'Coinbase' : channel[0]\n  const to = channel[2]\n  const from = channel[1]\n // subscribe to the CryptoCompare trade channel for the pair and exchange\n  return `0~${exchange}~${from}~${to}`\n}\n"]},"metadata":{},"sourceType":"module"}